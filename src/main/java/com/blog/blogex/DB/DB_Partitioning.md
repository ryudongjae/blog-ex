# 🧑🏻‍💻DB 파티셔닝
서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 구모 또한 대용량화 되면서, 기존에 사용하는  DB 시스템의 용량의 한계와 성능의 저하를 가져오게 되고 VLDB와 같이 하나의 DBMS에 너무 큰 table이 들어가면서 용량과 성능 측면에서 많은 이슈가 발생하게 되었고 , 이런 이슈를 해결하기 위한 방법으로 테이블을 파티션이라는 작은 단위로 나누어 관리하는 파티셔닝 기법이 나타나게 되었다.


파티셔닝은 논리적인 데이터 element들을 다수의 entity로 쪼개는 행위를 뜻하는 일반적인 용어이다. 
큰 테이블이나 인덱스를 관리하기 쉬운 파티션이라는 작은 단위로 물리적으로 분할하는 것을 의미한다. 
DB에 접근하는 Application의 입장에서는 물리적인 데이터 분할이 있지만 인식하지 못한다.

#### 파티셔닝의 목적으로는 성능, 가용성, 관리 이용성 등이 있다.

**성능적인 측면**에는 특정 DML(Data Manipulation Language : 데이터 조작 언어)과 Query의 성능을 향상하고, Full Scan에서 데이터 Access의 범위를 줄여 성능 향상을 가져온다. 또, 대용량 Data Write 환경에 효율적이다.
많은 Insert가 있는 OLTP 시스템에서 Insert작업을 작은 단위인 partition들로 분산시켜 경합을 줄인다.

**가용성적인 측면**에는 물리적인 파티셔닝으로 인해 전체적인 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상되고 , 각 분할 영역(partiton 별로)을 독립적으로 백업하고 복구할 수 있다.
테이블의 patition 단위로 Disk I/O를 분산하여 경합을 줄이기 때문에 UPDATE 성능을 향상한다.

**관리 이용성 측면**에는 큰 테이블들을 제거하여 관리를 쉽게 해 준다.

### 🛠파티셔닝 장단점

###장점
* 관리적 측면에서는 파티션 단위의 백업, 추가, 삭제, 변경이 가능하여 전체 데이터를 손실할 가능성이 줄어들어 데이터 가용성이 향상된다. 
* 파티션 단위로 백업 및 복구가 가능하다. 
* 파티션 단위로 I/O분산이 가능하여 UPDATE 성능을 향상한다. 
* 성능적 측면에서는 파티션 단위 조회 및 DML 수행이 가능하여 FULL SCAN에서 데이터 허용 범위를 줄여 성능 향상을 가져온다. 
* 필요한 데이터만 빠르게 조회할 수 있기 때문에 쿼리 자체가 가볍다.

###단점
* 테이블 간 조인에 대한 비용이 증가하고 테이블과 인덱스를 별도로 파티셔닝 할 수 없다.
* 테이블과 인덱스를 같이 파티셔닝 해야 한다

## ➡️수평 파티셔닝

하나의 테이블의 각 행을 다른 테이블에 분산시키는 것이다.
샤딩()과 동일한 개념이고 스키마를 복제한 후 샤드 키를 기준으로 데이터를 나누는 것을 말한다.
즉, 스키마가 같은 데이터를  두 개 이상의 테이블에 나누어 저장하는 것을 말한다.

###특징
    퍼포먼스, 가용성을 위해 key 기반으로 여러 곳에 분산 저장하고 일반적으로 분산 저장 기술에서 파티셔닝은 수평 분할을 의미한다.
    보통 수평 분할을 한다고 했을 때는 하나의 데이터베이스 안에서 이루어지는 경우를 지칭한다.
###장점
    데이터의 개수를 기준으로 나누어 파티셔닝 한다.
    데이터의 개수가 작아지고 따라서 인덱스의 개수도 작아지게 된다. 자연스럽게 성능은 향상된다.
###단점
    서버 간의 연결과정이 많아진다.
    데이터를 찾는 과정이 기존보다 복잡하기 때문에 lantency가 증가하게 된다.
    하나의 서버가 고장 나게 되면 데이터의 무결성이 깨질 수 있다.

## ➡️수직 파티셔닝
    
    테이블의 일부 열을 빼내는 형태로 분할한다.
    모든 칼럼들 중 특정 컬럼들을 쪼개서 따로 저장하는 형태이고 스키마를 나누고 데이터가 따라 옮겨 가는 것을 말한다.즉 , 하나의 엔티티를 2개이상으로 분리하는 작업이다.

### 🛠수직 파티셔닝 장점
    자주 사용하는 컬럼 등을 분리시켜 성능을 향상할 수 있다.
    한 테이블을 SELECT 하면 결국 모든 칼럼을 메모리에 올리게 되므로 필요없는 컬럼까지 올라가서 한 번에 읽을 수 있는 ROW가 줄어든다. 이는 I/O 측면에서 봤을 때 필요한 컬럼만 올리면 훨씬 많은 수의 ROW를 메모리에 올릴 수 있으니 성능상의 이점이 있다.
    같은 타입의 데이터가 저장되기 때문에 저장 시 데이터 압축률을 높일 수 있다.

## 💡파티셔닝(partitioning) 분할 기준

###📁Range Partitioning [범위 파티셔닝]  
    create table 주문( 주문번호 number, 주문일자 varchar2(8), 고객id varchar2(5) )  
    partition by range(주문일자) (  
    partition p2009_q1 values less than('20090401')  
    , partition p2009_q2 values less than('20090701')  
    , partition p2009_q3 values less than('20091001')  
    , partition p2009_q4 values less than('20100101')  
    , partition p2010_q1 values less than('20100401')  
    , partition p9999_mx values less than( MAXVALUE )  
    );  
파티셔닝 테이블에 값을 입력하면 각 레코드를 파티션 키 컬럼 값에 따라 분할 저장하고, 읽을 때도 검색 조건을 만족하는 파티션만 읽을 수 있어 데이터 조회 시 성능을 크게 향상해준다.  
파티션 키로는 하나 이상의 칼럼을 지정할 수 있고, 최대 16개까지 허용된다. 보관 주기 정책에 따라 과거 데이터가 저장된 파티션만 백업하고 삭제하는 등 데이터 관리 작업을 효율적이고 빠르게 수행할 수 있는 것도 큰 장점이다.  
관리자의 실수로 신규 파티션 생성을 빠트리면 월초 또는 연초에 데이터가 입력되지 않는 에러가 발생하므로, maxvalue 파티션을 반드시 생성해 두는 것이 좋다.  

### 📁Hash Partitioning [해시 파티셔닝]
파티션 키에 해시함수를 적용한 결과 값이 같은 레코드를 같은 파티션 세그먼트에 저장해 두는 방식
검색할 때는 조건절 비교 값에 해시함수를 적용해 읽어야 할 파티션을 결정하며, 해시 알고리즘 특성상 “==” ,“In-List” 이 두 조건으로 검색할 때만 파티션 Pruning이 동작한다.  
테이블 파티셔닝 여부를 결정할 대는 데이터가 얼마나 고르게 분산될 수 있느냐가 중요한 관심사이다. 해시 파티셔닝 할 때 특히 데이터 분포를 신중히 고려해야 하는데, 사용자가 직접 파티션 기준을 정하는 Range, 리스트 파티셔닝과 다르게 해시 파티셔닝은 파티션 개수만 사용자가 결정한다.

### 📁List Partitioning  
    create table 인터넷매물( 물건코드varchar2(5), 지역?류varchar2(4) )  
    partition by list(지역?류)  
    (partition p_지역1 values ('서울'),  
    partition p_지역2 values ('경기', '인천'),  
    partition p_지역3 values ('부산', '대구', '대전', '광주'),  
    partition p_기타values (DEFAULT) ) ;  
* 순서와 상관없이 불연속적인 값의 목록으로써 결정된다.  
* 단일 칼럼으로만 파티션 키를 지정해야 한다.  
* 리스트 파티션에도 default파티션을 생성해 두어야 안전하다.

### 📁 결합 파티셔닝  
결합 파티셔닝을 구성하면서 서브 파티션마다 세그먼트를 하나씩 할당하고 서브 파티션 단위로 데이터를 저장한다.  
주 파티션 키에 따라 1차적으로 데이터를 분배하고, 서브 파티션 키에 따라 최종적으로 저장할 위치를 결정한다.
 
 