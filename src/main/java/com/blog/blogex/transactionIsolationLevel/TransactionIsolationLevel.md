트랜잭션 격리 수준(TransactionIsolationLevel)
===

### 👉 정의
    트랜잭션 격리 수준은 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지 나타내는 것 
트랜잭션 격리수준은 크게 4가지로 나뉜다.
1. READ UNCOMMITED
2. READ COMMITED
3. REPEATABLE READ
4. SERIALIZBLE  

아래로 내려갈수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적이다.   
데이터베이스는 ACID특징과 같이 트랜잭션이 독립적인 수행을 하도록 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는것이 필요하다.  
하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게되면 데이터베이스의 성능은 떨어지게 된다.  
성능을 높이기 위해서는 무작정 Locking의 범위를 줄이기보다 최대한 효율적인 Locking이 필요하다.

우선 Locking에 대해서 간단하게 알아보자
####Locking
* Lock : 트랜잭션 마다 처리의 순차성을 보장하기 위한 방법이다.(동시성제어)
  * DBMS 마다 Lock을 구현하는 방식이 다르기 때문에 DBMS를 효과적으로 이용하기 위해서 해당 DB의 Lock에 대한 이해가 필요하다.

  * Shared(공유) lock 
    * 데이터를 읽을 때 사용되어지는 lock 
    * 공유락은 공유락끼리 동시에 접근이 가능하다.
    * 그러나 공유락이 설정된 데이터에 배타락을 사용할 수는 없다.
  * Exclusive(배타) lock
    * 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때까지 유지된다.
    * Lock이 해제될 떄까지 다른 트랜잭션을 해당 리소스에 접근할 수 없다.
    * 해당 락은 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 락을 설정할 수 없다.

### READ UNCOMMITED (Lv.0)
* 커밋되지 않은 데이터에 접근이 가능하 수준으로, N개의 트랜잭션이 하나의 공유 데이터에 접근해도 전혀 보호되지 않는다.
* 데이터베이스의 일관성을 유지하는 것이 불가능함
* Dirty Read 발생 : 데이터 정합성 문제가 많이 발생한다.
### READ COMMITED (Lv.1)
* SELECT 쿼리가 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 레벨이다.
* 트랜잭션이 수행하는 동안 다른 트랜잭션이 접근할 수 없어 대기하게되고, 커밋이 이루어진 트랜잭션만 조회가 가능하다.
* Non-Repeatable Read 발생 
* 오라클 데이터베이스와 SQL 서버에서 기본으로 사용하는 격리 수준이다.
### REPEATABLE READ (Lv.2)
* 트랜잭샨이 완료될 때까지 Select 문이 사용되는 모든 데이터에 Shared Lock이 걸린다.
* 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장한다.
* 다른 클라이언트는 트랜잭션 영역에 해당되는 데이터에 대한 수정이 불가능하다.
* MYSQL에서 기본으로 사용한다.
* Non-Repeatable Read 부정합이 발생하지 않고, 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된것만 보게된다.

### SERIALIZBLE  (Lv.3)
* 트랜잭션이 완료될 때까지 조회쿼리가 사용되는 모든 데이터에 Shared Lock이 걸리는 레벨
* 가장 엄격한 격리 수준으로 완벽한 읽기 일관성 모드를 제공하고, 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정이나 입력이 불가능하다.

격리 수준이 높아질수록 트랜잭션간 고립 정도가 높아지며, 성능이 저하된다. 
일반적으로 온라인 서비스에는 READ-COMMITED 나 REPEATABLE READ 중 하나를 사용한다.


### 낮은 레벨의 격리 수준을 활용할 떄 발생하는 현상들 
* Dirty Read
  * 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 볼수있다.
* Non-Repeatable Read
  * 한 트랜잭션에서 같은 쿼리를 2번 수행할 때 그 사이에 다른 트랜잭션 값을 수정하거나 삭제하면서  두쿼리의 결과가 다르게 나오는 현상
* Phantom Read
  * 한 트랜잭션안에서 일정범위의 데이터를 2번 이상 읽었을 때, 첫번째 쿼리에서 없던 데이터가 두번째 쿼리에서 나타나는 현상


    